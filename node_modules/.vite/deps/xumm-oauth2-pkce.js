import {
  require_src
} from "./chunk-USJQ2QQ4.js";
import {
  __commonJS,
  __require
} from "./chunk-7D4SUZUM.js";

// node_modules/events/events.js
var require_events = __commonJS({
  "node_modules/events/events.js"(exports, module) {
    "use strict";
    var R = typeof Reflect === "object" ? Reflect : null;
    var ReflectApply = R && typeof R.apply === "function" ? R.apply : function ReflectApply2(target, receiver, args) {
      return Function.prototype.apply.call(target, receiver, args);
    };
    var ReflectOwnKeys;
    if (R && typeof R.ownKeys === "function") {
      ReflectOwnKeys = R.ownKeys;
    } else if (Object.getOwnPropertySymbols) {
      ReflectOwnKeys = function ReflectOwnKeys2(target) {
        return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
      };
    } else {
      ReflectOwnKeys = function ReflectOwnKeys2(target) {
        return Object.getOwnPropertyNames(target);
      };
    }
    function ProcessEmitWarning(warning) {
      if (console && console.warn) console.warn(warning);
    }
    var NumberIsNaN = Number.isNaN || function NumberIsNaN2(value) {
      return value !== value;
    };
    function EventEmitter() {
      EventEmitter.init.call(this);
    }
    module.exports = EventEmitter;
    module.exports.once = once;
    EventEmitter.EventEmitter = EventEmitter;
    EventEmitter.prototype._events = void 0;
    EventEmitter.prototype._eventsCount = 0;
    EventEmitter.prototype._maxListeners = void 0;
    var defaultMaxListeners = 10;
    function checkListener(listener) {
      if (typeof listener !== "function") {
        throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
      }
    }
    Object.defineProperty(EventEmitter, "defaultMaxListeners", {
      enumerable: true,
      get: function() {
        return defaultMaxListeners;
      },
      set: function(arg) {
        if (typeof arg !== "number" || arg < 0 || NumberIsNaN(arg)) {
          throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + ".");
        }
        defaultMaxListeners = arg;
      }
    });
    EventEmitter.init = function() {
      if (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) {
        this._events = /* @__PURE__ */ Object.create(null);
        this._eventsCount = 0;
      }
      this._maxListeners = this._maxListeners || void 0;
    };
    EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
      if (typeof n !== "number" || n < 0 || NumberIsNaN(n)) {
        throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + ".");
      }
      this._maxListeners = n;
      return this;
    };
    function _getMaxListeners(that) {
      if (that._maxListeners === void 0)
        return EventEmitter.defaultMaxListeners;
      return that._maxListeners;
    }
    EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
      return _getMaxListeners(this);
    };
    EventEmitter.prototype.emit = function emit(type) {
      var args = [];
      for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);
      var doError = type === "error";
      var events = this._events;
      if (events !== void 0)
        doError = doError && events.error === void 0;
      else if (!doError)
        return false;
      if (doError) {
        var er;
        if (args.length > 0)
          er = args[0];
        if (er instanceof Error) {
          throw er;
        }
        var err = new Error("Unhandled error." + (er ? " (" + er.message + ")" : ""));
        err.context = er;
        throw err;
      }
      var handler = events[type];
      if (handler === void 0)
        return false;
      if (typeof handler === "function") {
        ReflectApply(handler, this, args);
      } else {
        var len = handler.length;
        var listeners = arrayClone(handler, len);
        for (var i = 0; i < len; ++i)
          ReflectApply(listeners[i], this, args);
      }
      return true;
    };
    function _addListener(target, type, listener, prepend) {
      var m;
      var events;
      var existing;
      checkListener(listener);
      events = target._events;
      if (events === void 0) {
        events = target._events = /* @__PURE__ */ Object.create(null);
        target._eventsCount = 0;
      } else {
        if (events.newListener !== void 0) {
          target.emit(
            "newListener",
            type,
            listener.listener ? listener.listener : listener
          );
          events = target._events;
        }
        existing = events[type];
      }
      if (existing === void 0) {
        existing = events[type] = listener;
        ++target._eventsCount;
      } else {
        if (typeof existing === "function") {
          existing = events[type] = prepend ? [listener, existing] : [existing, listener];
        } else if (prepend) {
          existing.unshift(listener);
        } else {
          existing.push(listener);
        }
        m = _getMaxListeners(target);
        if (m > 0 && existing.length > m && !existing.warned) {
          existing.warned = true;
          var w = new Error("Possible EventEmitter memory leak detected. " + existing.length + " " + String(type) + " listeners added. Use emitter.setMaxListeners() to increase limit");
          w.name = "MaxListenersExceededWarning";
          w.emitter = target;
          w.type = type;
          w.count = existing.length;
          ProcessEmitWarning(w);
        }
      }
      return target;
    }
    EventEmitter.prototype.addListener = function addListener(type, listener) {
      return _addListener(this, type, listener, false);
    };
    EventEmitter.prototype.on = EventEmitter.prototype.addListener;
    EventEmitter.prototype.prependListener = function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };
    function onceWrapper() {
      if (!this.fired) {
        this.target.removeListener(this.type, this.wrapFn);
        this.fired = true;
        if (arguments.length === 0)
          return this.listener.call(this.target);
        return this.listener.apply(this.target, arguments);
      }
    }
    function _onceWrap(target, type, listener) {
      var state = { fired: false, wrapFn: void 0, target, type, listener };
      var wrapped = onceWrapper.bind(state);
      wrapped.listener = listener;
      state.wrapFn = wrapped;
      return wrapped;
    }
    EventEmitter.prototype.once = function once2(type, listener) {
      checkListener(listener);
      this.on(type, _onceWrap(this, type, listener));
      return this;
    };
    EventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {
      checkListener(listener);
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };
    EventEmitter.prototype.removeListener = function removeListener(type, listener) {
      var list, events, position, i, originalListener;
      checkListener(listener);
      events = this._events;
      if (events === void 0)
        return this;
      list = events[type];
      if (list === void 0)
        return this;
      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = /* @__PURE__ */ Object.create(null);
        else {
          delete events[type];
          if (events.removeListener)
            this.emit("removeListener", type, list.listener || listener);
        }
      } else if (typeof list !== "function") {
        position = -1;
        for (i = list.length - 1; i >= 0; i--) {
          if (list[i] === listener || list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }
        if (position < 0)
          return this;
        if (position === 0)
          list.shift();
        else {
          spliceOne(list, position);
        }
        if (list.length === 1)
          events[type] = list[0];
        if (events.removeListener !== void 0)
          this.emit("removeListener", type, originalListener || listener);
      }
      return this;
    };
    EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
    EventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {
      var listeners, events, i;
      events = this._events;
      if (events === void 0)
        return this;
      if (events.removeListener === void 0) {
        if (arguments.length === 0) {
          this._events = /* @__PURE__ */ Object.create(null);
          this._eventsCount = 0;
        } else if (events[type] !== void 0) {
          if (--this._eventsCount === 0)
            this._events = /* @__PURE__ */ Object.create(null);
          else
            delete events[type];
        }
        return this;
      }
      if (arguments.length === 0) {
        var keys = Object.keys(events);
        var key;
        for (i = 0; i < keys.length; ++i) {
          key = keys[i];
          if (key === "removeListener") continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners("removeListener");
        this._events = /* @__PURE__ */ Object.create(null);
        this._eventsCount = 0;
        return this;
      }
      listeners = events[type];
      if (typeof listeners === "function") {
        this.removeListener(type, listeners);
      } else if (listeners !== void 0) {
        for (i = listeners.length - 1; i >= 0; i--) {
          this.removeListener(type, listeners[i]);
        }
      }
      return this;
    };
    function _listeners(target, type, unwrap) {
      var events = target._events;
      if (events === void 0)
        return [];
      var evlistener = events[type];
      if (evlistener === void 0)
        return [];
      if (typeof evlistener === "function")
        return unwrap ? [evlistener.listener || evlistener] : [evlistener];
      return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
    }
    EventEmitter.prototype.listeners = function listeners(type) {
      return _listeners(this, type, true);
    };
    EventEmitter.prototype.rawListeners = function rawListeners(type) {
      return _listeners(this, type, false);
    };
    EventEmitter.listenerCount = function(emitter, type) {
      if (typeof emitter.listenerCount === "function") {
        return emitter.listenerCount(type);
      } else {
        return listenerCount.call(emitter, type);
      }
    };
    EventEmitter.prototype.listenerCount = listenerCount;
    function listenerCount(type) {
      var events = this._events;
      if (events !== void 0) {
        var evlistener = events[type];
        if (typeof evlistener === "function") {
          return 1;
        } else if (evlistener !== void 0) {
          return evlistener.length;
        }
      }
      return 0;
    }
    EventEmitter.prototype.eventNames = function eventNames() {
      return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
    };
    function arrayClone(arr, n) {
      var copy = new Array(n);
      for (var i = 0; i < n; ++i)
        copy[i] = arr[i];
      return copy;
    }
    function spliceOne(list, index) {
      for (; index + 1 < list.length; index++)
        list[index] = list[index + 1];
      list.pop();
    }
    function unwrapListeners(arr) {
      var ret = new Array(arr.length);
      for (var i = 0; i < ret.length; ++i) {
        ret[i] = arr[i].listener || arr[i];
      }
      return ret;
    }
    function once(emitter, name) {
      return new Promise(function(resolve, reject) {
        function errorListener(err) {
          emitter.removeListener(name, resolver);
          reject(err);
        }
        function resolver() {
          if (typeof emitter.removeListener === "function") {
            emitter.removeListener("error", errorListener);
          }
          resolve([].slice.call(arguments));
        }
        ;
        eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });
        if (name !== "error") {
          addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
        }
      });
    }
    function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
      if (typeof emitter.on === "function") {
        eventTargetAgnosticAddListener(emitter, "error", handler, flags);
      }
    }
    function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
      if (typeof emitter.on === "function") {
        if (flags.once) {
          emitter.once(name, listener);
        } else {
          emitter.on(name, listener);
        }
      } else if (typeof emitter.addEventListener === "function") {
        emitter.addEventListener(name, function wrapListener(arg) {
          if (flags.once) {
            emitter.removeEventListener(name, wrapListener);
          }
          listener(arg);
        });
      } else {
        throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
      }
    }
  }
});

// browser-external:crypto
var require_crypto = __commonJS({
  "browser-external:crypto"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "crypto" has been externalized for browser compatibility. Cannot access "crypto.${key}" in client code. See https://vite.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/crypto-js/core.js
var require_core = __commonJS({
  "node_modules/crypto-js/core.js"(exports, module) {
    (function(root, factory) {
      if (typeof exports === "object") {
        module.exports = exports = factory();
      } else if (typeof define === "function" && define.amd) {
        define([], factory);
      } else {
        root.CryptoJS = factory();
      }
    })(exports, function() {
      var CryptoJS = CryptoJS || function(Math2, undefined2) {
        var crypto;
        if (typeof window !== "undefined" && window.crypto) {
          crypto = window.crypto;
        }
        if (typeof self !== "undefined" && self.crypto) {
          crypto = self.crypto;
        }
        if (typeof globalThis !== "undefined" && globalThis.crypto) {
          crypto = globalThis.crypto;
        }
        if (!crypto && typeof window !== "undefined" && window.msCrypto) {
          crypto = window.msCrypto;
        }
        if (!crypto && typeof global !== "undefined" && global.crypto) {
          crypto = global.crypto;
        }
        if (!crypto && typeof __require === "function") {
          try {
            crypto = require_crypto();
          } catch (err) {
          }
        }
        var cryptoSecureRandomInt = function() {
          if (crypto) {
            if (typeof crypto.getRandomValues === "function") {
              try {
                return crypto.getRandomValues(new Uint32Array(1))[0];
              } catch (err) {
              }
            }
            if (typeof crypto.randomBytes === "function") {
              try {
                return crypto.randomBytes(4).readInt32LE();
              } catch (err) {
              }
            }
          }
          throw new Error("Native crypto module could not be used to get secure random number.");
        };
        var create = Object.create || /* @__PURE__ */ function() {
          function F() {
          }
          return function(obj) {
            var subtype;
            F.prototype = obj;
            subtype = new F();
            F.prototype = null;
            return subtype;
          };
        }();
        var C = {};
        var C_lib = C.lib = {};
        var Base = C_lib.Base = /* @__PURE__ */ function() {
          return {
            /**
             * Creates a new object that inherits from this object.
             *
             * @param {Object} overrides Properties to copy into the new object.
             *
             * @return {Object} The new object.
             *
             * @static
             *
             * @example
             *
             *     var MyType = CryptoJS.lib.Base.extend({
             *         field: 'value',
             *
             *         method: function () {
             *         }
             *     });
             */
            extend: function(overrides) {
              var subtype = create(this);
              if (overrides) {
                subtype.mixIn(overrides);
              }
              if (!subtype.hasOwnProperty("init") || this.init === subtype.init) {
                subtype.init = function() {
                  subtype.$super.init.apply(this, arguments);
                };
              }
              subtype.init.prototype = subtype;
              subtype.$super = this;
              return subtype;
            },
            /**
             * Extends this object and runs the init method.
             * Arguments to create() will be passed to init().
             *
             * @return {Object} The new object.
             *
             * @static
             *
             * @example
             *
             *     var instance = MyType.create();
             */
            create: function() {
              var instance = this.extend();
              instance.init.apply(instance, arguments);
              return instance;
            },
            /**
             * Initializes a newly created object.
             * Override this method to add some logic when your objects are created.
             *
             * @example
             *
             *     var MyType = CryptoJS.lib.Base.extend({
             *         init: function () {
             *             // ...
             *         }
             *     });
             */
            init: function() {
            },
            /**
             * Copies properties into this object.
             *
             * @param {Object} properties The properties to mix in.
             *
             * @example
             *
             *     MyType.mixIn({
             *         field: 'value'
             *     });
             */
            mixIn: function(properties) {
              for (var propertyName in properties) {
                if (properties.hasOwnProperty(propertyName)) {
                  this[propertyName] = properties[propertyName];
                }
              }
              if (properties.hasOwnProperty("toString")) {
                this.toString = properties.toString;
              }
            },
            /**
             * Creates a copy of this object.
             *
             * @return {Object} The clone.
             *
             * @example
             *
             *     var clone = instance.clone();
             */
            clone: function() {
              return this.init.prototype.extend(this);
            }
          };
        }();
        var WordArray = C_lib.WordArray = Base.extend({
          /**
           * Initializes a newly created word array.
           *
           * @param {Array} words (Optional) An array of 32-bit words.
           * @param {number} sigBytes (Optional) The number of significant bytes in the words.
           *
           * @example
           *
           *     var wordArray = CryptoJS.lib.WordArray.create();
           *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607]);
           *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607], 6);
           */
          init: function(words, sigBytes) {
            words = this.words = words || [];
            if (sigBytes != undefined2) {
              this.sigBytes = sigBytes;
            } else {
              this.sigBytes = words.length * 4;
            }
          },
          /**
           * Converts this word array to a string.
           *
           * @param {Encoder} encoder (Optional) The encoding strategy to use. Default: CryptoJS.enc.Hex
           *
           * @return {string} The stringified word array.
           *
           * @example
           *
           *     var string = wordArray + '';
           *     var string = wordArray.toString();
           *     var string = wordArray.toString(CryptoJS.enc.Utf8);
           */
          toString: function(encoder) {
            return (encoder || Hex).stringify(this);
          },
          /**
           * Concatenates a word array to this word array.
           *
           * @param {WordArray} wordArray The word array to append.
           *
           * @return {WordArray} This word array.
           *
           * @example
           *
           *     wordArray1.concat(wordArray2);
           */
          concat: function(wordArray) {
            var thisWords = this.words;
            var thatWords = wordArray.words;
            var thisSigBytes = this.sigBytes;
            var thatSigBytes = wordArray.sigBytes;
            this.clamp();
            if (thisSigBytes % 4) {
              for (var i = 0; i < thatSigBytes; i++) {
                var thatByte = thatWords[i >>> 2] >>> 24 - i % 4 * 8 & 255;
                thisWords[thisSigBytes + i >>> 2] |= thatByte << 24 - (thisSigBytes + i) % 4 * 8;
              }
            } else {
              for (var j = 0; j < thatSigBytes; j += 4) {
                thisWords[thisSigBytes + j >>> 2] = thatWords[j >>> 2];
              }
            }
            this.sigBytes += thatSigBytes;
            return this;
          },
          /**
           * Removes insignificant bits.
           *
           * @example
           *
           *     wordArray.clamp();
           */
          clamp: function() {
            var words = this.words;
            var sigBytes = this.sigBytes;
            words[sigBytes >>> 2] &= 4294967295 << 32 - sigBytes % 4 * 8;
            words.length = Math2.ceil(sigBytes / 4);
          },
          /**
           * Creates a copy of this word array.
           *
           * @return {WordArray} The clone.
           *
           * @example
           *
           *     var clone = wordArray.clone();
           */
          clone: function() {
            var clone = Base.clone.call(this);
            clone.words = this.words.slice(0);
            return clone;
          },
          /**
           * Creates a word array filled with random bytes.
           *
           * @param {number} nBytes The number of random bytes to generate.
           *
           * @return {WordArray} The random word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.lib.WordArray.random(16);
           */
          random: function(nBytes) {
            var words = [];
            for (var i = 0; i < nBytes; i += 4) {
              words.push(cryptoSecureRandomInt());
            }
            return new WordArray.init(words, nBytes);
          }
        });
        var C_enc = C.enc = {};
        var Hex = C_enc.Hex = {
          /**
           * Converts a word array to a hex string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @return {string} The hex string.
           *
           * @static
           *
           * @example
           *
           *     var hexString = CryptoJS.enc.Hex.stringify(wordArray);
           */
          stringify: function(wordArray) {
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            var hexChars = [];
            for (var i = 0; i < sigBytes; i++) {
              var bite = words[i >>> 2] >>> 24 - i % 4 * 8 & 255;
              hexChars.push((bite >>> 4).toString(16));
              hexChars.push((bite & 15).toString(16));
            }
            return hexChars.join("");
          },
          /**
           * Converts a hex string to a word array.
           *
           * @param {string} hexStr The hex string.
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Hex.parse(hexString);
           */
          parse: function(hexStr) {
            var hexStrLength = hexStr.length;
            var words = [];
            for (var i = 0; i < hexStrLength; i += 2) {
              words[i >>> 3] |= parseInt(hexStr.substr(i, 2), 16) << 24 - i % 8 * 4;
            }
            return new WordArray.init(words, hexStrLength / 2);
          }
        };
        var Latin1 = C_enc.Latin1 = {
          /**
           * Converts a word array to a Latin1 string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @return {string} The Latin1 string.
           *
           * @static
           *
           * @example
           *
           *     var latin1String = CryptoJS.enc.Latin1.stringify(wordArray);
           */
          stringify: function(wordArray) {
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            var latin1Chars = [];
            for (var i = 0; i < sigBytes; i++) {
              var bite = words[i >>> 2] >>> 24 - i % 4 * 8 & 255;
              latin1Chars.push(String.fromCharCode(bite));
            }
            return latin1Chars.join("");
          },
          /**
           * Converts a Latin1 string to a word array.
           *
           * @param {string} latin1Str The Latin1 string.
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Latin1.parse(latin1String);
           */
          parse: function(latin1Str) {
            var latin1StrLength = latin1Str.length;
            var words = [];
            for (var i = 0; i < latin1StrLength; i++) {
              words[i >>> 2] |= (latin1Str.charCodeAt(i) & 255) << 24 - i % 4 * 8;
            }
            return new WordArray.init(words, latin1StrLength);
          }
        };
        var Utf8 = C_enc.Utf8 = {
          /**
           * Converts a word array to a UTF-8 string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @return {string} The UTF-8 string.
           *
           * @static
           *
           * @example
           *
           *     var utf8String = CryptoJS.enc.Utf8.stringify(wordArray);
           */
          stringify: function(wordArray) {
            try {
              return decodeURIComponent(escape(Latin1.stringify(wordArray)));
            } catch (e) {
              throw new Error("Malformed UTF-8 data");
            }
          },
          /**
           * Converts a UTF-8 string to a word array.
           *
           * @param {string} utf8Str The UTF-8 string.
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Utf8.parse(utf8String);
           */
          parse: function(utf8Str) {
            return Latin1.parse(unescape(encodeURIComponent(utf8Str)));
          }
        };
        var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm = Base.extend({
          /**
           * Resets this block algorithm's data buffer to its initial state.
           *
           * @example
           *
           *     bufferedBlockAlgorithm.reset();
           */
          reset: function() {
            this._data = new WordArray.init();
            this._nDataBytes = 0;
          },
          /**
           * Adds new data to this block algorithm's buffer.
           *
           * @param {WordArray|string} data The data to append. Strings are converted to a WordArray using UTF-8.
           *
           * @example
           *
           *     bufferedBlockAlgorithm._append('data');
           *     bufferedBlockAlgorithm._append(wordArray);
           */
          _append: function(data) {
            if (typeof data == "string") {
              data = Utf8.parse(data);
            }
            this._data.concat(data);
            this._nDataBytes += data.sigBytes;
          },
          /**
           * Processes available data blocks.
           *
           * This method invokes _doProcessBlock(offset), which must be implemented by a concrete subtype.
           *
           * @param {boolean} doFlush Whether all blocks and partial blocks should be processed.
           *
           * @return {WordArray} The processed data.
           *
           * @example
           *
           *     var processedData = bufferedBlockAlgorithm._process();
           *     var processedData = bufferedBlockAlgorithm._process(!!'flush');
           */
          _process: function(doFlush) {
            var processedWords;
            var data = this._data;
            var dataWords = data.words;
            var dataSigBytes = data.sigBytes;
            var blockSize = this.blockSize;
            var blockSizeBytes = blockSize * 4;
            var nBlocksReady = dataSigBytes / blockSizeBytes;
            if (doFlush) {
              nBlocksReady = Math2.ceil(nBlocksReady);
            } else {
              nBlocksReady = Math2.max((nBlocksReady | 0) - this._minBufferSize, 0);
            }
            var nWordsReady = nBlocksReady * blockSize;
            var nBytesReady = Math2.min(nWordsReady * 4, dataSigBytes);
            if (nWordsReady) {
              for (var offset = 0; offset < nWordsReady; offset += blockSize) {
                this._doProcessBlock(dataWords, offset);
              }
              processedWords = dataWords.splice(0, nWordsReady);
              data.sigBytes -= nBytesReady;
            }
            return new WordArray.init(processedWords, nBytesReady);
          },
          /**
           * Creates a copy of this object.
           *
           * @return {Object} The clone.
           *
           * @example
           *
           *     var clone = bufferedBlockAlgorithm.clone();
           */
          clone: function() {
            var clone = Base.clone.call(this);
            clone._data = this._data.clone();
            return clone;
          },
          _minBufferSize: 0
        });
        var Hasher = C_lib.Hasher = BufferedBlockAlgorithm.extend({
          /**
           * Configuration options.
           */
          cfg: Base.extend(),
          /**
           * Initializes a newly created hasher.
           *
           * @param {Object} cfg (Optional) The configuration options to use for this hash computation.
           *
           * @example
           *
           *     var hasher = CryptoJS.algo.SHA256.create();
           */
          init: function(cfg) {
            this.cfg = this.cfg.extend(cfg);
            this.reset();
          },
          /**
           * Resets this hasher to its initial state.
           *
           * @example
           *
           *     hasher.reset();
           */
          reset: function() {
            BufferedBlockAlgorithm.reset.call(this);
            this._doReset();
          },
          /**
           * Updates this hasher with a message.
           *
           * @param {WordArray|string} messageUpdate The message to append.
           *
           * @return {Hasher} This hasher.
           *
           * @example
           *
           *     hasher.update('message');
           *     hasher.update(wordArray);
           */
          update: function(messageUpdate) {
            this._append(messageUpdate);
            this._process();
            return this;
          },
          /**
           * Finalizes the hash computation.
           * Note that the finalize operation is effectively a destructive, read-once operation.
           *
           * @param {WordArray|string} messageUpdate (Optional) A final message update.
           *
           * @return {WordArray} The hash.
           *
           * @example
           *
           *     var hash = hasher.finalize();
           *     var hash = hasher.finalize('message');
           *     var hash = hasher.finalize(wordArray);
           */
          finalize: function(messageUpdate) {
            if (messageUpdate) {
              this._append(messageUpdate);
            }
            var hash = this._doFinalize();
            return hash;
          },
          blockSize: 512 / 32,
          /**
           * Creates a shortcut function to a hasher's object interface.
           *
           * @param {Hasher} hasher The hasher to create a helper for.
           *
           * @return {Function} The shortcut function.
           *
           * @static
           *
           * @example
           *
           *     var SHA256 = CryptoJS.lib.Hasher._createHelper(CryptoJS.algo.SHA256);
           */
          _createHelper: function(hasher) {
            return function(message, cfg) {
              return new hasher.init(cfg).finalize(message);
            };
          },
          /**
           * Creates a shortcut function to the HMAC's object interface.
           *
           * @param {Hasher} hasher The hasher to use in this HMAC helper.
           *
           * @return {Function} The shortcut function.
           *
           * @static
           *
           * @example
           *
           *     var HmacSHA256 = CryptoJS.lib.Hasher._createHmacHelper(CryptoJS.algo.SHA256);
           */
          _createHmacHelper: function(hasher) {
            return function(message, key) {
              return new C_algo.HMAC.init(hasher, key).finalize(message);
            };
          }
        });
        var C_algo = C.algo = {};
        return C;
      }(Math);
      return CryptoJS;
    });
  }
});

// node_modules/crypto-js/sha256.js
var require_sha256 = __commonJS({
  "node_modules/crypto-js/sha256.js"(exports, module) {
    (function(root, factory) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function(Math2) {
        var C = CryptoJS;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var Hasher = C_lib.Hasher;
        var C_algo = C.algo;
        var H = [];
        var K = [];
        (function() {
          function isPrime(n2) {
            var sqrtN = Math2.sqrt(n2);
            for (var factor = 2; factor <= sqrtN; factor++) {
              if (!(n2 % factor)) {
                return false;
              }
            }
            return true;
          }
          function getFractionalBits(n2) {
            return (n2 - (n2 | 0)) * 4294967296 | 0;
          }
          var n = 2;
          var nPrime = 0;
          while (nPrime < 64) {
            if (isPrime(n)) {
              if (nPrime < 8) {
                H[nPrime] = getFractionalBits(Math2.pow(n, 1 / 2));
              }
              K[nPrime] = getFractionalBits(Math2.pow(n, 1 / 3));
              nPrime++;
            }
            n++;
          }
        })();
        var W = [];
        var SHA256 = C_algo.SHA256 = Hasher.extend({
          _doReset: function() {
            this._hash = new WordArray.init(H.slice(0));
          },
          _doProcessBlock: function(M, offset) {
            var H2 = this._hash.words;
            var a = H2[0];
            var b = H2[1];
            var c = H2[2];
            var d = H2[3];
            var e = H2[4];
            var f = H2[5];
            var g = H2[6];
            var h = H2[7];
            for (var i = 0; i < 64; i++) {
              if (i < 16) {
                W[i] = M[offset + i] | 0;
              } else {
                var gamma0x = W[i - 15];
                var gamma0 = (gamma0x << 25 | gamma0x >>> 7) ^ (gamma0x << 14 | gamma0x >>> 18) ^ gamma0x >>> 3;
                var gamma1x = W[i - 2];
                var gamma1 = (gamma1x << 15 | gamma1x >>> 17) ^ (gamma1x << 13 | gamma1x >>> 19) ^ gamma1x >>> 10;
                W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16];
              }
              var ch = e & f ^ ~e & g;
              var maj = a & b ^ a & c ^ b & c;
              var sigma0 = (a << 30 | a >>> 2) ^ (a << 19 | a >>> 13) ^ (a << 10 | a >>> 22);
              var sigma1 = (e << 26 | e >>> 6) ^ (e << 21 | e >>> 11) ^ (e << 7 | e >>> 25);
              var t1 = h + sigma1 + ch + K[i] + W[i];
              var t2 = sigma0 + maj;
              h = g;
              g = f;
              f = e;
              e = d + t1 | 0;
              d = c;
              c = b;
              b = a;
              a = t1 + t2 | 0;
            }
            H2[0] = H2[0] + a | 0;
            H2[1] = H2[1] + b | 0;
            H2[2] = H2[2] + c | 0;
            H2[3] = H2[3] + d | 0;
            H2[4] = H2[4] + e | 0;
            H2[5] = H2[5] + f | 0;
            H2[6] = H2[6] + g | 0;
            H2[7] = H2[7] + h | 0;
          },
          _doFinalize: function() {
            var data = this._data;
            var dataWords = data.words;
            var nBitsTotal = this._nDataBytes * 8;
            var nBitsLeft = data.sigBytes * 8;
            dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = Math2.floor(nBitsTotal / 4294967296);
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 15] = nBitsTotal;
            data.sigBytes = dataWords.length * 4;
            this._process();
            return this._hash;
          },
          clone: function() {
            var clone = Hasher.clone.call(this);
            clone._hash = this._hash.clone();
            return clone;
          }
        });
        C.SHA256 = Hasher._createHelper(SHA256);
        C.HmacSHA256 = Hasher._createHmacHelper(SHA256);
      })(Math);
      return CryptoJS.SHA256;
    });
  }
});

// node_modules/crypto-js/enc-base64.js
var require_enc_base64 = __commonJS({
  "node_modules/crypto-js/enc-base64.js"(exports, module) {
    (function(root, factory) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function() {
        var C = CryptoJS;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var C_enc = C.enc;
        var Base64 = C_enc.Base64 = {
          /**
           * Converts a word array to a Base64 string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @return {string} The Base64 string.
           *
           * @static
           *
           * @example
           *
           *     var base64String = CryptoJS.enc.Base64.stringify(wordArray);
           */
          stringify: function(wordArray) {
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            var map = this._map;
            wordArray.clamp();
            var base64Chars = [];
            for (var i = 0; i < sigBytes; i += 3) {
              var byte1 = words[i >>> 2] >>> 24 - i % 4 * 8 & 255;
              var byte2 = words[i + 1 >>> 2] >>> 24 - (i + 1) % 4 * 8 & 255;
              var byte3 = words[i + 2 >>> 2] >>> 24 - (i + 2) % 4 * 8 & 255;
              var triplet = byte1 << 16 | byte2 << 8 | byte3;
              for (var j = 0; j < 4 && i + j * 0.75 < sigBytes; j++) {
                base64Chars.push(map.charAt(triplet >>> 6 * (3 - j) & 63));
              }
            }
            var paddingChar = map.charAt(64);
            if (paddingChar) {
              while (base64Chars.length % 4) {
                base64Chars.push(paddingChar);
              }
            }
            return base64Chars.join("");
          },
          /**
           * Converts a Base64 string to a word array.
           *
           * @param {string} base64Str The Base64 string.
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Base64.parse(base64String);
           */
          parse: function(base64Str) {
            var base64StrLength = base64Str.length;
            var map = this._map;
            var reverseMap = this._reverseMap;
            if (!reverseMap) {
              reverseMap = this._reverseMap = [];
              for (var j = 0; j < map.length; j++) {
                reverseMap[map.charCodeAt(j)] = j;
              }
            }
            var paddingChar = map.charAt(64);
            if (paddingChar) {
              var paddingIndex = base64Str.indexOf(paddingChar);
              if (paddingIndex !== -1) {
                base64StrLength = paddingIndex;
              }
            }
            return parseLoop(base64Str, base64StrLength, reverseMap);
          },
          _map: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="
        };
        function parseLoop(base64Str, base64StrLength, reverseMap) {
          var words = [];
          var nBytes = 0;
          for (var i = 0; i < base64StrLength; i++) {
            if (i % 4) {
              var bits1 = reverseMap[base64Str.charCodeAt(i - 1)] << i % 4 * 2;
              var bits2 = reverseMap[base64Str.charCodeAt(i)] >>> 6 - i % 4 * 2;
              var bitsCombined = bits1 | bits2;
              words[nBytes >>> 2] |= bitsCombined << 24 - nBytes % 4 * 8;
              nBytes++;
            }
          }
          return WordArray.create(words, nBytes);
        }
      })();
      return CryptoJS.enc.Base64;
    });
  }
});

// node_modules/crypto-js/lib-typedarrays.js
var require_lib_typedarrays = __commonJS({
  "node_modules/crypto-js/lib-typedarrays.js"(exports, module) {
    (function(root, factory) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function() {
        if (typeof ArrayBuffer != "function") {
          return;
        }
        var C = CryptoJS;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var superInit = WordArray.init;
        var subInit = WordArray.init = function(typedArray) {
          if (typedArray instanceof ArrayBuffer) {
            typedArray = new Uint8Array(typedArray);
          }
          if (typedArray instanceof Int8Array || typeof Uint8ClampedArray !== "undefined" && typedArray instanceof Uint8ClampedArray || typedArray instanceof Int16Array || typedArray instanceof Uint16Array || typedArray instanceof Int32Array || typedArray instanceof Uint32Array || typedArray instanceof Float32Array || typedArray instanceof Float64Array) {
            typedArray = new Uint8Array(typedArray.buffer, typedArray.byteOffset, typedArray.byteLength);
          }
          if (typedArray instanceof Uint8Array) {
            var typedArrayByteLength = typedArray.byteLength;
            var words = [];
            for (var i = 0; i < typedArrayByteLength; i++) {
              words[i >>> 2] |= typedArray[i] << 24 - i % 4 * 8;
            }
            superInit.call(this, words, typedArrayByteLength);
          } else {
            superInit.apply(this, arguments);
          }
        };
        subInit.prototype = WordArray;
      })();
      return CryptoJS.lib.WordArray;
    });
  }
});

// node_modules/xumm-js-pkce/dist/PKCE.js
var require_PKCE = __commonJS({
  "node_modules/xumm-js-pkce/dist/PKCE.js"(exports) {
    "use strict";
    var __assign = exports && exports.__assign || function() {
      __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var sha256_1 = __importDefault(require_sha256());
    var enc_base64_1 = __importDefault(require_enc_base64());
    var lib_typedarrays_1 = __importDefault(require_lib_typedarrays());
    var PKCE = (
      /** @class */
      function() {
        function PKCE2(config) {
          this.state = "";
          this.codeVerifier = "";
          this.config = config;
        }
        PKCE2.prototype.authorizeUrl = function(additionalParams) {
          var _a, _b;
          if (additionalParams === void 0) {
            additionalParams = {};
          }
          var queryString = new URLSearchParams(Object.assign(__assign({ response_type: ((_a = this.config) === null || _a === void 0 ? void 0 : _a.implicit) ? "token" : "code", client_id: this.config.client_id, state: this.getState(additionalParams.state || null), scope: this.config.requested_scopes, redirect_uri: this.config.redirect_uri }, ((_b = this.config) === null || _b === void 0 ? void 0 : _b.implicit) ? {} : {
            code_challenge: this.pkceChallengeFromVerifier(),
            code_challenge_method: "S256"
          }), additionalParams)).toString();
          return "".concat(this.config.authorization_endpoint, "?").concat(queryString);
        };
        PKCE2.prototype.exchangeForAccessToken = function(url, additionalParams) {
          var _this = this;
          if (additionalParams === void 0) {
            additionalParams = {};
          }
          return this.parseAuthResponseUrl(url).then(function(q) {
            var _a, _b;
            if ((_a = _this.config) === null || _a === void 0 ? void 0 : _a.implicit) {
              var tokenResponse_1 = {
                access_token: "",
                expires_in: 0,
                refresh_expires_in: 0,
                refresh_token: "",
                scope: "",
                token_type: ""
              };
              var urlParams = new URL(url).searchParams;
              urlParams.forEach(function(val, key) {
                if (Object.keys(tokenResponse_1).indexOf(key) > -1) {
                  tokenResponse_1[key] = typeof tokenResponse_1[key] === "number" ? Number(val) : String(val);
                }
              });
              return Promise.resolve(Object.assign(tokenResponse_1, additionalParams));
            }
            return fetch(_this.config.token_endpoint, {
              method: "POST",
              body: new URLSearchParams(Object.assign(__assign({ grant_type: "authorization_code", code: q.code, client_id: _this.config.client_id, redirect_uri: _this.config.redirect_uri }, ((_b = _this.config) === null || _b === void 0 ? void 0 : _b.implicit) ? {} : {
                code_verifier: _this.getCodeVerifier()
              }), additionalParams)),
              headers: {
                Accept: "application/json",
                "Content-Type": "application/x-www-form-urlencoded;charset=UTF-8"
              }
            }).then(function(response) {
              return response.json();
            });
          });
        };
        PKCE2.prototype.getCodeVerifier = function() {
          if (this.codeVerifier === "") {
            this.codeVerifier = this.randomStringFromStorage("pkce_code_verifier");
          }
          return this.codeVerifier;
        };
        PKCE2.prototype.getState = function(explicit) {
          if (explicit === void 0) {
            explicit = null;
          }
          var stateKey = "pkce_state";
          if (explicit !== null) {
            this.getStore().setItem(stateKey, explicit);
          }
          if (this.state === "") {
            this.state = this.randomStringFromStorage(stateKey);
          }
          return this.state;
        };
        PKCE2.prototype.parseAuthResponseUrl = function(url) {
          var params = new URL(url).searchParams;
          return this.validateAuthResponse({
            error: params.get("error"),
            query: params.get("query"),
            state: params.get("state"),
            code: params.get("code")
          });
        };
        PKCE2.prototype.pkceChallengeFromVerifier = function() {
          var hashed = (0, sha256_1.default)(this.getCodeVerifier());
          return enc_base64_1.default.stringify(hashed).replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/, "");
        };
        PKCE2.prototype.randomStringFromStorage = function(key) {
          var fromStorage = this.getStore().getItem(key);
          if (fromStorage === null) {
            this.getStore().setItem(key, lib_typedarrays_1.default.random(64));
          }
          return this.getStore().getItem(key) || "";
        };
        PKCE2.prototype.validateAuthResponse = function(queryParams) {
          var _this = this;
          return new Promise(function(resolve, reject) {
            var _a;
            if (queryParams.error) {
              return reject({ error: queryParams.error });
            }
            if (queryParams.state !== _this.getState() && !((_a = _this.config) === null || _a === void 0 ? void 0 : _a.implicit)) {
              return reject({ error: "Invalid State" });
            }
            return resolve(queryParams);
          });
        };
        PKCE2.prototype.getStore = function() {
          var _a;
          return ((_a = this.config) === null || _a === void 0 ? void 0 : _a.storage) || sessionStorage;
        };
        return PKCE2;
      }()
    );
    exports.default = PKCE;
  }
});

// node_modules/xumm-oauth2-pkce/dist/index.js
var require_dist = __commonJS({
  "node_modules/xumm-oauth2-pkce/dist/index.js"(exports) {
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.XummPkce = exports.XummPkceThread = void 0;
    var events_1 = require_events();
    var xumm_sdk_1 = require_src();
    var xumm_js_pkce_1 = __importDefault(require_PKCE());
    var log = function(...args) {
      if (typeof localStorage !== "undefined") {
        if (localStorage === null || localStorage === void 0 ? void 0 : localStorage.debug) {
          console.log(...args);
        }
      }
    };
    if (typeof window !== "undefined") {
      log("Xumm OAuth2 PKCE Authorization Code Flow lib.");
    }
    var EventReadyPromise = (event) => {
      let _resolve = (value) => {
      };
      const promise = new Promise((resolve) => {
        _resolve = resolve;
      });
      return {
        promise,
        resolve: (value) => {
          return _resolve(value);
        }
      };
    };
    var XummPkceThread = class extends events_1.EventEmitter {
      constructor(xummApiKey, optionsOrRedirectUrl) {
        var _a, _b;
        super();
        this.popup = null;
        this.resolved = false;
        this.mobileRedirectFlow = false;
        this.eventPromises = {
          retrieved: EventReadyPromise("retrieved"),
          error: EventReadyPromise("error"),
          success: EventReadyPromise("success"),
          loggedout: EventReadyPromise("loggedout")
        };
        this.options = {
          redirectUrl: document.location.href,
          rememberJwt: true,
          storage: localStorage,
          implicit: false
        };
        if (typeof optionsOrRedirectUrl === "string") {
          this.options.redirectUrl = optionsOrRedirectUrl;
        } else if (typeof optionsOrRedirectUrl === "object" && optionsOrRedirectUrl) {
          if (typeof optionsOrRedirectUrl.redirectUrl === "string") {
            this.options.redirectUrl = optionsOrRedirectUrl.redirectUrl;
          }
          if (typeof optionsOrRedirectUrl.rememberJwt === "boolean") {
            this.options.rememberJwt = optionsOrRedirectUrl.rememberJwt;
          }
          if (typeof optionsOrRedirectUrl.storage === "object") {
            this.options.storage = optionsOrRedirectUrl.storage;
          }
          if (typeof optionsOrRedirectUrl.implicit === "boolean") {
            this.options.implicit = optionsOrRedirectUrl.implicit;
          }
        }
        const pkceOptions = {
          client_id: xummApiKey,
          redirect_uri: this.options.redirectUrl,
          authorization_endpoint: "https://oauth2.xumm.app/auth",
          token_endpoint: "https://oauth2.xumm.app/token",
          requested_scopes: "XummPkce",
          storage: this.options.storage,
          implicit: this.options.implicit
        };
        this.pkce = new xumm_js_pkce_1.default(pkceOptions);
        if (this.options.rememberJwt) {
          log("Remember JWT");
          try {
            const existingJwt = JSON.parse(((_a = this.options.storage) === null || _a === void 0 ? void 0 : _a.getItem("XummPkceJwt")) || "{}");
            if ((existingJwt === null || existingJwt === void 0 ? void 0 : existingJwt.jwt) && typeof existingJwt.jwt === "string") {
              const sdk = new xumm_sdk_1.XummSdkJwt(existingJwt.jwt);
              this.ping = sdk.ping();
              this.ping.then((pong) => __awaiter(this, void 0, void 0, function* () {
                var _c;
                if ((_c = pong === null || pong === void 0 ? void 0 : pong.jwtData) === null || _c === void 0 ? void 0 : _c.sub) {
                  this.autoResolvedFlow = Object.assign(existingJwt, { sdk });
                  yield this.authorize();
                  this.emit("retrieved");
                } else {
                  this.logout();
                }
              })).catch((e) => {
                this.logout();
              });
            } else {
              this.logout();
            }
          } catch (e) {
          }
        }
        window.addEventListener("message", (event) => {
          var _a2;
          log("Received Event from ", event.origin);
          if (String((event === null || event === void 0 ? void 0 : event.data) || "").slice(0, 1) === "{" && String((event === null || event === void 0 ? void 0 : event.data) || "").slice(-1) === "}") {
            log("Got PostMessage with JSON");
            if (event.origin === "https://xumm.app" || event.origin === "https://oauth2.xumm.app") {
              log("Got PostMessage from https://xumm.app / https://oauth2.xumm.app");
              try {
                const postMessage = JSON.parse(event.data);
                if ((postMessage === null || postMessage === void 0 ? void 0 : postMessage.source) === "xumm_sign_request" && (postMessage === null || postMessage === void 0 ? void 0 : postMessage.payload)) {
                  log("Payload opened:", postMessage.payload);
                } else if ((postMessage === null || postMessage === void 0 ? void 0 : postMessage.source) === "xumm_sign_request_resolved" && (postMessage === null || postMessage === void 0 ? void 0 : postMessage.options)) {
                  log("Payload resolved, mostmessage containing options containing redirect URL: ", postMessage);
                  this.resolved = true;
                  this.pkce.exchangeForAccessToken(postMessage.options.full_redirect_uri).then((resp) => {
                    this.jwt = resp.access_token;
                    if (resp === null || resp === void 0 ? void 0 : resp.error_description) {
                      throw new Error(resp === null || resp === void 0 ? void 0 : resp.error_description);
                    }
                    fetch("https://oauth2.xumm.app/userinfo", {
                      headers: {
                        Authorization: "Bearer " + resp.access_token
                      }
                    }).then((r) => r.json()).then((me) => {
                      var _a3;
                      if (this.resolvePromise) {
                        if (this.options.rememberJwt) {
                          log("Remembering JWT");
                          try {
                            (_a3 = this.options.storage) === null || _a3 === void 0 ? void 0 : _a3.setItem("XummPkceJwt", JSON.stringify({ jwt: resp.access_token, me }));
                          } catch (e) {
                            log("Could not persist JWT to local storage", e);
                          }
                        }
                        this.resolvePromise({
                          jwt: resp.access_token,
                          sdk: new xumm_sdk_1.XummSdkJwt(resp.access_token),
                          me
                        });
                      }
                    });
                  }).catch((e) => {
                    if (this.rejectPromise) {
                      this.rejectPromise((e === null || e === void 0 ? void 0 : e.error) ? new Error(e.error) : e);
                    }
                    log((e === null || e === void 0 ? void 0 : e.error) || e);
                  });
                } else if ((postMessage === null || postMessage === void 0 ? void 0 : postMessage.source) === "xumm_sign_request_rejected") {
                  log("Payload rejected", postMessage === null || postMessage === void 0 ? void 0 : postMessage.options);
                  if (this.rejectPromise) {
                    this.rejectPromise(new Error(((_a2 = postMessage === null || postMessage === void 0 ? void 0 : postMessage.options) === null || _a2 === void 0 ? void 0 : _a2.error_description) || "Payload rejected"));
                  }
                } else if ((postMessage === null || postMessage === void 0 ? void 0 : postMessage.source) === "xumm_sign_request_popup_closed") {
                  log("Popup closed, wait 750ms");
                  setTimeout(() => {
                    if (!this.resolved && this.rejectPromise) {
                      this.rejectPromise(new Error("Sign In window closed"));
                    }
                  }, 750);
                } else {
                  log("Unexpected message, skipping", postMessage === null || postMessage === void 0 ? void 0 : postMessage.source);
                }
              } catch (e) {
                log("Error parsing message", (e === null || e === void 0 ? void 0 : e.message) || e);
              }
            }
          }
        }, false);
        const params = new URLSearchParams(((_b = document === null || document === void 0 ? void 0 : document.location) === null || _b === void 0 ? void 0 : _b.search) || "");
        if (params.get("authorization_code") || params.get("access_token") || params.get("error_description")) {
          this.mobileRedirectFlow = true;
          this.urlParams = params;
          let documentReadyExecuted = false;
          const onDocumentReady = (event) => __awaiter(this, void 0, void 0, function* () {
            log("onDocumentReady", document.readyState);
            if (!documentReadyExecuted && document.readyState === "complete") {
              documentReadyExecuted = true;
              log("(readystatechange: [ " + document.readyState + " ])");
              this.handleMobileGrant();
              yield this.authorize();
              this.emit("retrieved");
            }
          });
          onDocumentReady();
          document.addEventListener("readystatechange", onDocumentReady);
        }
      }
      emit(event, ...args) {
        this.eventPromises[event].promise.then(() => {
          return super.emit(event, ...args);
        });
        return true;
      }
      on(event, listener) {
        this.eventPromises[event].resolve();
        return super.on(event, listener);
      }
      off(event, listener) {
        this.eventPromises[event] = EventReadyPromise(event);
        return super.off(event, listener);
      }
      // Todo: document, e.g. custom flow, plugin
      authorizeUrl() {
        return this.pkce.authorizeUrl();
      }
      handleMobileGrant() {
        if (this.urlParams && this.mobileRedirectFlow) {
          const messageEventData = {
            data: JSON.stringify(this.urlParams.get("authorization_code") || this.urlParams.get("access_token") ? {
              source: "xumm_sign_request_resolved",
              options: {
                full_redirect_uri: document.location.href
              }
            } : {
              source: "xumm_sign_request_rejected",
              options: {
                error: this.urlParams.get("error"),
                error_code: this.urlParams.get("error_code"),
                error_description: this.urlParams.get("error_description")
              }
            }),
            origin: "https://oauth2.xumm.app"
          };
          const event = new MessageEvent("message", messageEventData);
          window.dispatchEvent(event);
          return true;
        }
        return false;
      }
      authorize() {
        return __awaiter(this, void 0, void 0, function* () {
          if (this.resolvedSuccessfully) {
            return this.promise;
          }
          this.resolved = false;
          try {
            yield this.ping;
          } catch (e) {
          }
          if (!this.mobileRedirectFlow && !this.autoResolvedFlow) {
            const url = this.authorizeUrl();
            const popup = window.open(url, "XummPkceLogin", "directories=no,titlebar=no,toolbar=no,location=no,status=no,menubar=no,scrollbars=no,resizable=no,width=600,height=790");
            this.popup = popup;
            log("Popup opened...", url);
          }
          this.resolved = false;
          const clearUrlParams = () => {
            var _a;
            const newUrlParams = new URLSearchParams(((_a = document === null || document === void 0 ? void 0 : document.location) === null || _a === void 0 ? void 0 : _a.search) || "");
            newUrlParams.delete("authorization_code");
            newUrlParams.delete("code");
            newUrlParams.delete("scope");
            newUrlParams.delete("state");
            newUrlParams.delete("access_token");
            newUrlParams.delete("refresh_token");
            newUrlParams.delete("token_type");
            newUrlParams.delete("expires_in");
            const newSearchParamsString = newUrlParams.toString();
            const url = document.location.href.split("?")[0] + (newSearchParamsString !== "" ? "?" : "") + newSearchParamsString;
            window.history.replaceState({ path: url }, "", url);
          };
          clearUrlParams();
          if (this.autoResolvedFlow) {
            if (!this.resolved) {
              this.resolved = true;
              this.promise = Promise.resolve(this.autoResolvedFlow);
              this.rejectPromise = this.resolvePromise = () => {
              };
              log("Auto resolved");
              this.emit("success");
            }
          } else {
            this.promise = new Promise((resolve, reject) => {
              this.resolvePromise = (_) => {
                const resolved = resolve(_);
                this.resolved = true;
                this.resolvedSuccessfully = true;
                log("Xumm Sign in RESOLVED");
                this.emit("success");
                return resolved;
              };
              this.rejectPromise = (_) => {
                const rejected = reject(_);
                this.resolved = true;
                this.emit("error", typeof _ === "string" ? new Error(_) : _);
                log("Xumm Sign in REJECTED");
                return rejected;
              };
            });
          }
          return this.promise;
        });
      }
      state() {
        return __awaiter(this, void 0, void 0, function* () {
          return this.promise;
        });
      }
      logout() {
        var _a;
        setTimeout(() => this.emit("loggedout"), 0);
        try {
          this.resolved = false;
          this.resolvedSuccessfully = void 0;
          this.autoResolvedFlow = void 0;
          (_a = this.options.storage) === null || _a === void 0 ? void 0 : _a.removeItem("XummPkceJwt");
          this.mobileRedirectFlow = false;
        } catch (e) {
        }
        return;
      }
      getPopup() {
        return this === null || this === void 0 ? void 0 : this.popup;
      }
    };
    exports.XummPkceThread = XummPkceThread;
    var thread = (_XummPkce) => {
      let attached = false;
      if (_XummPkce) {
        if (typeof window === "object") {
          if (typeof window._XummPkce === "undefined") {
            window._XummPkce = _XummPkce;
            attached = true;
          }
        }
      }
      const instance = window === null || window === void 0 ? void 0 : window._XummPkce;
      if (instance && attached) {
        log("XummPkce attached to window");
      }
      return instance;
    };
    var XummPkce = class {
      constructor(xummApiKey, optionsOrRedirectUrl) {
        if (typeof window === "undefined" || typeof document === "undefined") {
          return;
        }
        if (!thread()) {
          thread(new XummPkceThread(xummApiKey, optionsOrRedirectUrl));
        }
      }
      on(event, listener) {
        const t = thread();
        if (!t) {
          return;
        }
        t.on(event, listener);
        return this;
      }
      off(event, listener) {
        const t = thread();
        if (!t) {
          return;
        }
        t.off(event, listener);
        return this;
      }
      authorize() {
        const t = thread();
        if (!t) {
          return;
        }
        return t.authorize();
      }
      state() {
        const t = thread();
        if (!t) {
          return;
        }
        return t.state();
      }
      logout() {
        const t = thread();
        if (!t) {
          return;
        }
        return t.logout();
      }
    };
    exports.XummPkce = XummPkce;
  }
});
export default require_dist();
//# sourceMappingURL=xumm-oauth2-pkce.js.map
